// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: src/data.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// GPS Fix type enumeration
enum RKTGpsFix: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case noFix // = 0
  case deadReckoningOnly // = 1
  case fix2D // = 2
  case fix3D // = 3
  case gpsPlusDeadReckoning // = 4
  case timeOnlyFix // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .noFix
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noFix
    case 1: self = .deadReckoningOnly
    case 2: self = .fix2D
    case 3: self = .fix3D
    case 4: self = .gpsPlusDeadReckoning
    case 5: self = .timeOnlyFix
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .noFix: return 0
    case .deadReckoningOnly: return 1
    case .fix2D: return 2
    case .fix3D: return 3
    case .gpsPlusDeadReckoning: return 4
    case .timeOnlyFix: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [RKTGpsFix] = [
    .noFix,
    .deadReckoningOnly,
    .fix2D,
    .fix3D,
    .gpsPlusDeadReckoning,
    .timeOnlyFix,
  ]

}

/// UTC time representation
struct RKTUTC: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// GPS Millisecond Time of Week
  var itow: UInt32 = 0

  var timeAccuracyEstimateNs: UInt32 = 0

  /// Nanoseconds of second, range -1e9 .. 1e9
  var nanos: Int32 = 0

  /// Year, range 1999..2099
  var year: UInt32 = 0

  /// Month, range 1..12
  var month: UInt32 = 0

  /// Day of Month, range 1..31
  var day: UInt32 = 0

  /// Hour of Day, range 0..23
  var hour: UInt32 = 0

  /// Minute of Hour, range 0..59
  var min: UInt32 = 0

  /// Seconds of Minute, range 0..59
  var sec: UInt32 = 0

  var valid: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Main telemetry data structure
struct RKTMiniData: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timeSinceBoot: UInt64 {
    get {return _storage._timeSinceBoot}
    set {_uniqueStorage()._timeSinceBoot = newValue}
  }

  var msgNum: UInt32 {
    get {return _storage._msgNum}
    set {_uniqueStorage()._msgNum = newValue}
  }

  var lat: Double {
    get {return _storage._lat}
    set {_uniqueStorage()._lat = newValue}
  }

  var lon: Double {
    get {return _storage._lon}
    set {_uniqueStorage()._lon = newValue}
  }

  var alt: Double {
    get {return _storage._alt}
    set {_uniqueStorage()._alt = newValue}
  }

  var numSats: UInt32 {
    get {return _storage._numSats}
    set {_uniqueStorage()._numSats = newValue}
  }

  var gpsFix: RKTGpsFix {
    get {return _storage._gpsFix}
    set {_uniqueStorage()._gpsFix = newValue}
  }

  var gpsTime: RKTUTC {
    get {return _storage._gpsTime ?? RKTUTC()}
    set {_uniqueStorage()._gpsTime = newValue}
  }
  /// Returns true if `gpsTime` has been explicitly set.
  var hasGpsTime: Bool {return _storage._gpsTime != nil}
  /// Clears the value of `gpsTime`. Subsequent reads from it will return its default value.
  mutating func clearGpsTime() {_uniqueStorage()._gpsTime = nil}

  var baroAlt: Float {
    get {return _storage._baroAlt}
    set {_uniqueStorage()._baroAlt = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rocketry"

extension RKTGpsFix: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_FIX"),
    1: .same(proto: "DEAD_RECKONING_ONLY"),
    2: .same(proto: "FIX_2D"),
    3: .same(proto: "FIX_3D"),
    4: .same(proto: "GPS_PLUS_DEAD_RECKONING"),
    5: .same(proto: "TIME_ONLY_FIX"),
  ]
}

extension RKTUTC: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UTC"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "itow"),
    2: .standard(proto: "time_accuracy_estimate_ns"),
    3: .same(proto: "nanos"),
    4: .same(proto: "year"),
    5: .same(proto: "month"),
    6: .same(proto: "day"),
    7: .same(proto: "hour"),
    8: .same(proto: "min"),
    9: .same(proto: "sec"),
    10: .same(proto: "valid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.itow) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.timeAccuracyEstimateNs) }()
      case 3: try { try decoder.decodeSingularSFixed32Field(value: &self.nanos) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self.year) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self.month) }()
      case 6: try { try decoder.decodeSingularFixed32Field(value: &self.day) }()
      case 7: try { try decoder.decodeSingularFixed32Field(value: &self.hour) }()
      case 8: try { try decoder.decodeSingularFixed32Field(value: &self.min) }()
      case 9: try { try decoder.decodeSingularFixed32Field(value: &self.sec) }()
      case 10: try { try decoder.decodeSingularFixed32Field(value: &self.valid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.itow != 0 {
      try visitor.visitSingularFixed32Field(value: self.itow, fieldNumber: 1)
    }
    if self.timeAccuracyEstimateNs != 0 {
      try visitor.visitSingularFixed32Field(value: self.timeAccuracyEstimateNs, fieldNumber: 2)
    }
    if self.nanos != 0 {
      try visitor.visitSingularSFixed32Field(value: self.nanos, fieldNumber: 3)
    }
    if self.year != 0 {
      try visitor.visitSingularFixed32Field(value: self.year, fieldNumber: 4)
    }
    if self.month != 0 {
      try visitor.visitSingularFixed32Field(value: self.month, fieldNumber: 5)
    }
    if self.day != 0 {
      try visitor.visitSingularFixed32Field(value: self.day, fieldNumber: 6)
    }
    if self.hour != 0 {
      try visitor.visitSingularFixed32Field(value: self.hour, fieldNumber: 7)
    }
    if self.min != 0 {
      try visitor.visitSingularFixed32Field(value: self.min, fieldNumber: 8)
    }
    if self.sec != 0 {
      try visitor.visitSingularFixed32Field(value: self.sec, fieldNumber: 9)
    }
    if self.valid != 0 {
      try visitor.visitSingularFixed32Field(value: self.valid, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RKTUTC, rhs: RKTUTC) -> Bool {
    if lhs.itow != rhs.itow {return false}
    if lhs.timeAccuracyEstimateNs != rhs.timeAccuracyEstimateNs {return false}
    if lhs.nanos != rhs.nanos {return false}
    if lhs.year != rhs.year {return false}
    if lhs.month != rhs.month {return false}
    if lhs.day != rhs.day {return false}
    if lhs.hour != rhs.hour {return false}
    if lhs.min != rhs.min {return false}
    if lhs.sec != rhs.sec {return false}
    if lhs.valid != rhs.valid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RKTMiniData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MiniData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_since_boot"),
    2: .standard(proto: "msg_num"),
    3: .same(proto: "lat"),
    4: .same(proto: "lon"),
    5: .same(proto: "alt"),
    6: .standard(proto: "num_sats"),
    7: .standard(proto: "gps_fix"),
    8: .standard(proto: "gps_time"),
    9: .standard(proto: "baro_alt"),
  ]

  fileprivate class _StorageClass {
    var _timeSinceBoot: UInt64 = 0
    var _msgNum: UInt32 = 0
    var _lat: Double = 0
    var _lon: Double = 0
    var _alt: Double = 0
    var _numSats: UInt32 = 0
    var _gpsFix: RKTGpsFix = .noFix
    var _gpsTime: RKTUTC? = nil
    var _baroAlt: Float = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _timeSinceBoot = source._timeSinceBoot
      _msgNum = source._msgNum
      _lat = source._lat
      _lon = source._lon
      _alt = source._alt
      _numSats = source._numSats
      _gpsFix = source._gpsFix
      _gpsTime = source._gpsTime
      _baroAlt = source._baroAlt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularFixed64Field(value: &_storage._timeSinceBoot) }()
        case 2: try { try decoder.decodeSingularFixed32Field(value: &_storage._msgNum) }()
        case 3: try { try decoder.decodeSingularDoubleField(value: &_storage._lat) }()
        case 4: try { try decoder.decodeSingularDoubleField(value: &_storage._lon) }()
        case 5: try { try decoder.decodeSingularDoubleField(value: &_storage._alt) }()
        case 6: try { try decoder.decodeSingularFixed32Field(value: &_storage._numSats) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._gpsFix) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._gpsTime) }()
        case 9: try { try decoder.decodeSingularFloatField(value: &_storage._baroAlt) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._timeSinceBoot != 0 {
        try visitor.visitSingularFixed64Field(value: _storage._timeSinceBoot, fieldNumber: 1)
      }
      if _storage._msgNum != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._msgNum, fieldNumber: 2)
      }
      if _storage._lat.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._lat, fieldNumber: 3)
      }
      if _storage._lon.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._lon, fieldNumber: 4)
      }
      if _storage._alt.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._alt, fieldNumber: 5)
      }
      if _storage._numSats != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._numSats, fieldNumber: 6)
      }
      if _storage._gpsFix != .noFix {
        try visitor.visitSingularEnumField(value: _storage._gpsFix, fieldNumber: 7)
      }
      try { if let v = _storage._gpsTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._baroAlt.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._baroAlt, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RKTMiniData, rhs: RKTMiniData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._timeSinceBoot != rhs_storage._timeSinceBoot {return false}
        if _storage._msgNum != rhs_storage._msgNum {return false}
        if _storage._lat != rhs_storage._lat {return false}
        if _storage._lon != rhs_storage._lon {return false}
        if _storage._alt != rhs_storage._alt {return false}
        if _storage._numSats != rhs_storage._numSats {return false}
        if _storage._gpsFix != rhs_storage._gpsFix {return false}
        if _storage._gpsTime != rhs_storage._gpsTime {return false}
        if _storage._baroAlt != rhs_storage._baroAlt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
