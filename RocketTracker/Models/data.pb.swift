// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: src/data.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// GPS Fix type enumeration
enum RKTGpsFix: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// Unknown fix type (protobuf treats 0 enums as unset)
  case unknownGpsfix // = 0
  case noFix // = 1
  case deadReckoningOnly // = 2
  case fix2D // = 3
  case fix3D // = 4
  case gpsPlusDeadReckoning // = 5
  case timeOnlyFix // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownGpsfix
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownGpsfix
    case 1: self = .noFix
    case 2: self = .deadReckoningOnly
    case 3: self = .fix2D
    case 4: self = .fix3D
    case 5: self = .gpsPlusDeadReckoning
    case 6: self = .timeOnlyFix
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownGpsfix: return 0
    case .noFix: return 1
    case .deadReckoningOnly: return 2
    case .fix2D: return 3
    case .fix3D: return 4
    case .gpsPlusDeadReckoning: return 5
    case .timeOnlyFix: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [RKTGpsFix] = [
    .unknownGpsfix,
    .noFix,
    .deadReckoningOnly,
    .fix2D,
    .fix3D,
    .gpsPlusDeadReckoning,
    .timeOnlyFix,
  ]

}

/// The unified message format for all tracker data
struct RKTTrackerPacket: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common fields for all packet types
  var deviceID: UInt32 {
    get {return _storage._deviceID}
    set {_uniqueStorage()._deviceID = newValue}
  }

  var msgNum: UInt32 {
    get {return _storage._msgNum}
    set {_uniqueStorage()._msgNum = newValue}
  }

  var timeSinceBoot: UInt64 {
    get {return _storage._timeSinceBoot}
    set {_uniqueStorage()._timeSinceBoot = newValue}
  }

  var packetType: RKTTrackerPacket.PacketType {
    get {return _storage._packetType}
    set {_uniqueStorage()._packetType = newValue}
  }

  /// The actual payload (only one will be set per packet)
  var payload: OneOf_Payload? {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  var gps: RKTGpsData {
    get {
      if case .gps(let v)? = _storage._payload {return v}
      return RKTGpsData()
    }
    set {_uniqueStorage()._payload = .gps(newValue)}
  }

  var imu: RKTImuData {
    get {
      if case .imu(let v)? = _storage._payload {return v}
      return RKTImuData()
    }
    set {_uniqueStorage()._payload = .imu(newValue)}
  }

  var accel: RKTAccelData {
    get {
      if case .accel(let v)? = _storage._payload {return v}
      return RKTAccelData()
    }
    set {_uniqueStorage()._payload = .accel(newValue)}
  }

  var baro: RKTBaroData {
    get {
      if case .baro(let v)? = _storage._payload {return v}
      return RKTBaroData()
    }
    set {_uniqueStorage()._payload = .baro(newValue)}
  }

  var userLocation: RKTUserLocation {
    get {
      if case .userLocation(let v)? = _storage._payload {return v}
      return RKTUserLocation()
    }
    set {_uniqueStorage()._payload = .userLocation(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The actual payload (only one will be set per packet)
  enum OneOf_Payload: Equatable, Sendable {
    case gps(RKTGpsData)
    case imu(RKTImuData)
    case accel(RKTAccelData)
    case baro(RKTBaroData)
    case userLocation(RKTUserLocation)

  }

  /// Enum to identify the payload type
  enum PacketType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknown // = 0

    /// GPS position data
    case gps // = 1

    /// Primary IMU data
    case ismPrimary // = 2

    /// Secondary IMU data
    case ismSecondary // = 3

    /// LSM6DSO32 IMU data
    case lsm // = 4

    /// ADXL accelerometer
    case accel // = 5

    /// Barometer
    case baro // = 6

    /// User's phone location
    case userLocation // = 7
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .gps
      case 2: self = .ismPrimary
      case 3: self = .ismSecondary
      case 4: self = .lsm
      case 5: self = .accel
      case 6: self = .baro
      case 7: self = .userLocation
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .gps: return 1
      case .ismPrimary: return 2
      case .ismSecondary: return 3
      case .lsm: return 4
      case .accel: return 5
      case .baro: return 6
      case .userLocation: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RKTTrackerPacket.PacketType] = [
      .unknown,
      .gps,
      .ismPrimary,
      .ismSecondary,
      .lsm,
      .accel,
      .baro,
      .userLocation,
    ]

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// GPS position data (simplified from MiniData)
struct RKTGpsData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lat: Double = 0

  var lon: Double = 0

  var alt: Double = 0

  var numSats: UInt32 = 0

  var fixType: RKTGpsFix = .unknownGpsfix

  /// GPS Millisecond Time of Week
  var itow: UInt32 = 0

  var timeAccuracyEstimateNs: UInt32 = 0

  /// Nanoseconds of second, range -1e9 .. 1e9
  var nanos: Int32 = 0

  /// Year, range 1999..2099
  var year: Int32 = 0

  /// Month, range 1..12
  var month: Int32 = 0

  /// Day of Month, range 1..31
  var day: Int32 = 0

  /// Hour of Day, range 0..23
  var hour: Int32 = 0

  /// Minute of Hour, range 0..59
  var min: Int32 = 0

  /// Seconds of Minute, range 0..59
  var sec: Int32 = 0

  var valid: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RKTImuData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Accelerometer X-axis
  var accelX: Double = 0

  /// Accelerometer Y-axis
  var accelY: Double = 0

  /// Accelerometer Z-axis
  var accelZ: Double = 0

  /// Gyroscope X-axis
  var gyroX: Double = 0

  /// Gyroscope Y-axis
  var gyroY: Double = 0

  /// Gyroscope Z-axis
  var gyroZ: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RKTAccelData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Accelerometer X-axis
  var accelX: Double = 0

  /// Accelerometer Y-axis
  var accelY: Double = 0

  /// Accelerometer Z-axis
  var accelZ: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RKTBaroData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Altitude in meters
  var altitude: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RKTUserLocation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Latitude in degrees
  var lat: Double = 0

  /// Longitude in degrees
  var lon: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rocketry"

extension RKTGpsFix: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_GPSFIX"),
    1: .same(proto: "NO_FIX"),
    2: .same(proto: "DEAD_RECKONING_ONLY"),
    3: .same(proto: "FIX_2D"),
    4: .same(proto: "FIX_3D"),
    5: .same(proto: "GPS_PLUS_DEAD_RECKONING"),
    6: .same(proto: "TIME_ONLY_FIX"),
  ]
}

extension RKTTrackerPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrackerPacket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
    2: .standard(proto: "msg_num"),
    3: .standard(proto: "time_since_boot"),
    4: .standard(proto: "packet_type"),
    5: .same(proto: "gps"),
    6: .same(proto: "imu"),
    7: .same(proto: "accel"),
    8: .same(proto: "baro"),
    9: .standard(proto: "user_location"),
  ]

  fileprivate class _StorageClass {
    var _deviceID: UInt32 = 0
    var _msgNum: UInt32 = 0
    var _timeSinceBoot: UInt64 = 0
    var _packetType: RKTTrackerPacket.PacketType = .unknown
    var _payload: RKTTrackerPacket.OneOf_Payload?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _deviceID = source._deviceID
      _msgNum = source._msgNum
      _timeSinceBoot = source._timeSinceBoot
      _packetType = source._packetType
      _payload = source._payload
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._deviceID) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._msgNum) }()
        case 3: try { try decoder.decodeSingularFixed64Field(value: &_storage._timeSinceBoot) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._packetType) }()
        case 5: try {
          var v: RKTGpsData?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .gps(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .gps(v)
          }
        }()
        case 6: try {
          var v: RKTImuData?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .imu(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .imu(v)
          }
        }()
        case 7: try {
          var v: RKTAccelData?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .accel(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .accel(v)
          }
        }()
        case 8: try {
          var v: RKTBaroData?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .baro(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .baro(v)
          }
        }()
        case 9: try {
          var v: RKTUserLocation?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .userLocation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .userLocation(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._deviceID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._deviceID, fieldNumber: 1)
      }
      if _storage._msgNum != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._msgNum, fieldNumber: 2)
      }
      if _storage._timeSinceBoot != 0 {
        try visitor.visitSingularFixed64Field(value: _storage._timeSinceBoot, fieldNumber: 3)
      }
      if _storage._packetType != .unknown {
        try visitor.visitSingularEnumField(value: _storage._packetType, fieldNumber: 4)
      }
      switch _storage._payload {
      case .gps?: try {
        guard case .gps(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .imu?: try {
        guard case .imu(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .accel?: try {
        guard case .accel(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .baro?: try {
        guard case .baro(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .userLocation?: try {
        guard case .userLocation(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RKTTrackerPacket, rhs: RKTTrackerPacket) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._deviceID != rhs_storage._deviceID {return false}
        if _storage._msgNum != rhs_storage._msgNum {return false}
        if _storage._timeSinceBoot != rhs_storage._timeSinceBoot {return false}
        if _storage._packetType != rhs_storage._packetType {return false}
        if _storage._payload != rhs_storage._payload {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RKTTrackerPacket.PacketType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "GPS"),
    2: .same(proto: "ISM_PRIMARY"),
    3: .same(proto: "ISM_SECONDARY"),
    4: .same(proto: "LSM"),
    5: .same(proto: "ACCEL"),
    6: .same(proto: "BARO"),
    7: .same(proto: "USER_LOCATION"),
  ]
}

extension RKTGpsData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GpsData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lat"),
    2: .same(proto: "lon"),
    3: .same(proto: "alt"),
    4: .standard(proto: "num_sats"),
    5: .standard(proto: "fix_type"),
    6: .same(proto: "itow"),
    7: .standard(proto: "time_accuracy_estimate_ns"),
    8: .same(proto: "nanos"),
    9: .same(proto: "year"),
    10: .same(proto: "month"),
    11: .same(proto: "day"),
    12: .same(proto: "hour"),
    13: .same(proto: "min"),
    14: .same(proto: "sec"),
    15: .same(proto: "valid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.lat) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.lon) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.alt) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.numSats) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.fixType) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.itow) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.timeAccuracyEstimateNs) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.nanos) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.year) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.month) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.day) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.hour) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &self.min) }()
      case 14: try { try decoder.decodeSingularInt32Field(value: &self.sec) }()
      case 15: try { try decoder.decodeSingularInt32Field(value: &self.valid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lat.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.lat, fieldNumber: 1)
    }
    if self.lon.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.lon, fieldNumber: 2)
    }
    if self.alt.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.alt, fieldNumber: 3)
    }
    if self.numSats != 0 {
      try visitor.visitSingularUInt32Field(value: self.numSats, fieldNumber: 4)
    }
    if self.fixType != .unknownGpsfix {
      try visitor.visitSingularEnumField(value: self.fixType, fieldNumber: 5)
    }
    if self.itow != 0 {
      try visitor.visitSingularUInt32Field(value: self.itow, fieldNumber: 6)
    }
    if self.timeAccuracyEstimateNs != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeAccuracyEstimateNs, fieldNumber: 7)
    }
    if self.nanos != 0 {
      try visitor.visitSingularInt32Field(value: self.nanos, fieldNumber: 8)
    }
    if self.year != 0 {
      try visitor.visitSingularInt32Field(value: self.year, fieldNumber: 9)
    }
    if self.month != 0 {
      try visitor.visitSingularInt32Field(value: self.month, fieldNumber: 10)
    }
    if self.day != 0 {
      try visitor.visitSingularInt32Field(value: self.day, fieldNumber: 11)
    }
    if self.hour != 0 {
      try visitor.visitSingularInt32Field(value: self.hour, fieldNumber: 12)
    }
    if self.min != 0 {
      try visitor.visitSingularInt32Field(value: self.min, fieldNumber: 13)
    }
    if self.sec != 0 {
      try visitor.visitSingularInt32Field(value: self.sec, fieldNumber: 14)
    }
    if self.valid != 0 {
      try visitor.visitSingularInt32Field(value: self.valid, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RKTGpsData, rhs: RKTGpsData) -> Bool {
    if lhs.lat != rhs.lat {return false}
    if lhs.lon != rhs.lon {return false}
    if lhs.alt != rhs.alt {return false}
    if lhs.numSats != rhs.numSats {return false}
    if lhs.fixType != rhs.fixType {return false}
    if lhs.itow != rhs.itow {return false}
    if lhs.timeAccuracyEstimateNs != rhs.timeAccuracyEstimateNs {return false}
    if lhs.nanos != rhs.nanos {return false}
    if lhs.year != rhs.year {return false}
    if lhs.month != rhs.month {return false}
    if lhs.day != rhs.day {return false}
    if lhs.hour != rhs.hour {return false}
    if lhs.min != rhs.min {return false}
    if lhs.sec != rhs.sec {return false}
    if lhs.valid != rhs.valid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RKTImuData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImuData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "accel_x"),
    2: .standard(proto: "accel_y"),
    3: .standard(proto: "accel_z"),
    4: .standard(proto: "gyro_x"),
    5: .standard(proto: "gyro_y"),
    6: .standard(proto: "gyro_z"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.accelX) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.accelY) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.accelZ) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.gyroX) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.gyroY) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.gyroZ) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.accelX.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.accelX, fieldNumber: 1)
    }
    if self.accelY.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.accelY, fieldNumber: 2)
    }
    if self.accelZ.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.accelZ, fieldNumber: 3)
    }
    if self.gyroX.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.gyroX, fieldNumber: 4)
    }
    if self.gyroY.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.gyroY, fieldNumber: 5)
    }
    if self.gyroZ.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.gyroZ, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RKTImuData, rhs: RKTImuData) -> Bool {
    if lhs.accelX != rhs.accelX {return false}
    if lhs.accelY != rhs.accelY {return false}
    if lhs.accelZ != rhs.accelZ {return false}
    if lhs.gyroX != rhs.gyroX {return false}
    if lhs.gyroY != rhs.gyroY {return false}
    if lhs.gyroZ != rhs.gyroZ {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RKTAccelData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccelData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "accel_x"),
    2: .standard(proto: "accel_y"),
    3: .standard(proto: "accel_z"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.accelX) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.accelY) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.accelZ) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.accelX.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.accelX, fieldNumber: 1)
    }
    if self.accelY.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.accelY, fieldNumber: 2)
    }
    if self.accelZ.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.accelZ, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RKTAccelData, rhs: RKTAccelData) -> Bool {
    if lhs.accelX != rhs.accelX {return false}
    if lhs.accelY != rhs.accelY {return false}
    if lhs.accelZ != rhs.accelZ {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RKTBaroData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BaroData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "altitude"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.altitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.altitude.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.altitude, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RKTBaroData, rhs: RKTBaroData) -> Bool {
    if lhs.altitude != rhs.altitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RKTUserLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserLocation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lat"),
    2: .same(proto: "lon"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.lat) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.lon) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lat.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.lat, fieldNumber: 1)
    }
    if self.lon.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.lon, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RKTUserLocation, rhs: RKTUserLocation) -> Bool {
    if lhs.lat != rhs.lat {return false}
    if lhs.lon != rhs.lon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
